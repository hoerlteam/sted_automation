from copy import deepcopy

from pipeline2.utils.dict_utils import merge_dicts, remove_path_from_dict, get_path_from_dict, generate_nested_dict
from pipeline2.utils.parameter_constants import LOCATION_PARAMETERS


class ParameterFilter:

    def __init__(self, wrapped_callback, remove_parameters=True, acquisition_parameters=None, hardware_parameters=None):
        """
        Base class for filtering the updates generated by a wrapped callback, either by removing
        a set of parameters or by keeping only those parameters.

        Parameters
        ----------
        wrapped_callback: callable that returns a list of lists of (measurement updates, hardware updates) dicts
        remove_parameters (bool): whether to remove or keep parameters from updates
        measurement_parameters (iterable of str): parameter keys to keep or remove from measurement updates
        hardware_parameters (iterable of str): parameter keys to keep or remove from hardware updates
        """
        self.wrapped_callback = wrapped_callback
        self.acquisition_parameters = acquisition_parameters
        self.hardware_parameters = hardware_parameters
        self.remove_parameters_flag = remove_parameters

    def keep_parameters(self):
        new_updates = []
        # go over updates for each measurement created by callback
        for measurement_parameters_old in self.wrapped_callback():
            measurement_parameters_new = []
            # a measurement consists of multiple configurations, go over those
            for acquisition_updates_old, hardware_updates_old in measurement_parameters_old:
                # make new empty update dicts if we have to discard anything, else keep old ones
                acquisition_updates_new = {} if self.acquisition_parameters is not None else acquisition_updates_old
                hardware_updates_new = {} if self.hardware_parameters is not None else hardware_updates_old
                # if we need to update acquisition parameters, go over parameters to keep
                # and add them (with value from wrapped update) to new updates
                if self.acquisition_parameters is not None:
                    for acquisition_update_key in self.acquisition_parameters:
                        old_value = get_path_from_dict(acquisition_updates_old, acquisition_update_key, False)
                        acquisition_updates_new = merge_dicts(
                            acquisition_updates_new,
                            generate_nested_dict(old_value, acquisition_update_key) if old_value is not None else {}
                        )
                # if we need to update hardware parameters, go over parameters to keep
                # and add them (with value from wrapped update) to new updates
                if self.hardware_parameters is not None:
                    for hardware_update_key in self.hardware_parameters:
                        old_value = get_path_from_dict(hardware_updates_old, hardware_update_key, False)
                        hardware_updates_new = merge_dicts(
                            hardware_updates_new,
                            generate_nested_dict(old_value, hardware_update_key) if old_value is not None else {}
                        )
                measurement_parameters_new.append((acquisition_updates_new, hardware_updates_new))
            new_updates.append(measurement_parameters_new)
        return new_updates

    def remove_parameters(self):
        new_updates = []
        # go over updates for each measurement created by callback
        for measurement_parameters_old in self.wrapped_callback():
            measurement_parameters_new = []
            # a measurement consists of multiple configurations, go over those
            for acquisition_updates_old, hardware_updates_old in measurement_parameters_old:
                # we start with the old updates
                # NOTE: deepcopy probably not necessary here, maybe remove?
                acquisition_updates_new = deepcopy(acquisition_updates_old)
                hardware_updates_new = deepcopy(hardware_updates_old)
                # if we need to remove parameters from acquisition updates, drop them from new update dict
                if self.acquisition_parameters is not None:
                    for acquisition_update_key in self.acquisition_parameters:
                        acquisition_updates_new = remove_path_from_dict(acquisition_updates_new, acquisition_update_key)
                        if acquisition_updates_new is None:
                            acquisition_updates_new = {}
                # if we need to remove parameters from hardware updates, drop them from new update dict
                if self.hardware_parameters is not None:
                    for hardware_update_key in self.hardware_parameters:
                        hardware_updates_new = remove_path_from_dict(hardware_updates_new, hardware_update_key)
                        if hardware_updates_new is None:
                            hardware_updates_new = {}
                measurement_parameters_new.append((acquisition_updates_new, hardware_updates_new))
            new_updates.append(measurement_parameters_new)
        return new_updates

    def __call__(self):
        if self.remove_parameters_flag:
            return self.remove_parameters()
        else:
            return self.keep_parameters()


class LocationKeeper(ParameterFilter):
    """
    This wrapper can be used to keep just the location-related updates from the
    output of a settings generation callback.
    It will replace acquisition update dicts with a new, empty, dictionary
    and only add location-related updates
    """
    def __init__(self, wrapped_callback):
        """
        Parameters
        ----------
        wrapped_callback: callable that returns a list of lists of (measurement updates, hardware updates) dicts
        """
        super().__init__(wrapped_callback, remove_parameters=False, acquisition_parameters=LOCATION_PARAMETERS)


class LocationRemover(ParameterFilter):
    """
    This wrapper can be used to remove location-related updates from the output
    of a settings generation callback.
    It will remove the corresponding settings from every acquisition update dict
    and leave the rest as-is.
    """
    def __init__(self, wrapped_callback):
        """
        Parameters
        ----------
        wrapped_callback: callable that returns a list of lists of (measurement updates, hardware updates) dicts
        """
        super().__init__(wrapped_callback, remove_parameters=True, acquisition_parameters=LOCATION_PARAMETERS)